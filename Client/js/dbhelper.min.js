if('serviceWorker'in navigator){navigator.serviceWorker.register('/sw.js',{scope:'/'}).then(registration=>{console.log('Service Worker registration is successful!'+registration.scope)}).catch(error=>{console.log('Service worker registration failed:',error)})};if(typeof idb==='undefined'){self.importScripts('js/idb.js')}let fetchedCuisines;let fetchedNeighborhoods;class DBHelper{static get DATABASE_URL(){const port=1337;return `http://localhost:${ port }/restaurants`}static get DATABASE_REVIEWS_URL(){const port=1337;return `http://localhost:${ port }/reviews`}static fetchRestaurants(callback,id){let fetchURL;if(!id){fetchURL=DBHelper.DATABASE_URL}else{fetchURL=DBHelper.DATABASE_URL+"/"+id}fetch(fetchURL,{method:'GET'}).then(response=>{response.json().then(restaurants=>{if(restaurants.length){const neighborhoods=restaurants.map((v,i)=>restaurants[i].neighborhood);fetchedNeighborhoods=neighborhoods.filter((v,i)=>neighborhoods.indexOf(v)==i);const cuisines=restaurants.map((v,i)=>restaurants[i].cuisine_type);fetchedCuisines=cuisines.filter((v,i)=>cuisines.indexOf(v)==i)}dbPromise.then((db)=>{return dbPromise.then(db=>{const tx=db.transaction('restaurants','readwrite');const store=tx.objectStore('restaurants');for(const restaurant of restaurants){store.put(restaurant)}});return restaurants});callback(null,restaurants)})}).catch(error=>{callback(`Request failed. Returned status of ${error.statusText }`,null);dbPromise.then((db)=>{let restaurantObjectStore=db.transaction('restaurants').objectStore('restaurants');return restaurantObjectStore.getAll()})})}static fetchRestaurantById(id,callback){DBHelper.fetchRestaurants((error,restaurants)=>{if(error){callback(error,null)}else{const restaurant=restaurants.find(r=>r.id==id);if(restaurant){callback(null,restaurant)}else{callback('Restaurant does not exist',null)}}})}static fetchRestaurantReviewsById(id,callback){const fetchURL=DBHelper.DATABASE_REVIEWS_URL+"/?restaurant_id="+id;fetch(fetchURL,{method:'GET'}).then(response=>{response.json().then(reviews=>{dbPromise.then((db)=>{return dbPromise.then(db=>{const tx=db.transaction('reviews','readwrite');const store=tx.objectStore('reviews');for(const review of reviews){store.put(review)}});return reviews});callback(null,reviews)})}).catch(error=>{callback(`Request failed. Returned status of ${error.statusText }`,null);dbPromise.then((db)=>{let reviewObjectStore=db.transaction('reviews','readwrite').objectStore('reviews');return(offlineReviews)=>{console.log('getting offline reviews');return Promise.resolve(offlineReviews)};return reviewObjectStore.getAll()})})}static fetchRestaurantByCuisine(cuisine,callback){DBHelper.fetchRestaurants((error,restaurants)=>{if(error){callback(error,null)}else{const results=restaurants.filter(r=>r.cuisine_type==cuisine);callback(null,results)}})}static fetchRestaurantByNeighborhood(neighborhood,callback){DBHelper.fetchRestaurants((error,restaurants)=>{if(error){callback(error,null)}else{const results=restaurants.filter(r=>r.neighborhood==neighborhood);callback(null,results)}})}static fetchRestaurantByCuisineAndNeighborhood(cuisine,neighborhood,callback){DBHelper.fetchRestaurants((error,restaurants)=>{if(error){callback(error,null)}else{let results=restaurants;if(cuisine!='all'){results=results.filter(r=>r.cuisine_type==cuisine)}if(neighborhood!='all'){results=results.filter(r=>r.neighborhood==neighborhood)}callback(null,results)}})}static fetchNeighborhoods(callback){if(fetchedNeighborhoods){callback(null,fetchedNeighborhoods);return}DBHelper.fetchRestaurants((error,restaurants)=>{if(error){callback(error,null)}else{const neighborhoods=restaurants.map((v,i)=>restaurants[i].neighborhood);fetchedNeighborhoods=neighborhoods.filter((v,i)=>neighborhoods.indexOf(v)==i);callback(null,fetchedNeighborhoods)}})}static fetchCuisines(callback){if(fetchedCuisines){callback(null,fetchedCuisines);return}DBHelper.fetchRestaurants((error,restaurants)=>{if(error){callback(error,null)}else{const cuisines=restaurants.map((v,i)=>restaurants[i].cuisine_type);fetchedCuisines=cuisines.filter((v,i)=>cuisines.indexOf(v)==i);callback(null,fetchedCuisines)}})}static urlForRestaurant(restaurant){return(`./restaurant.html?id=${restaurant.id }`)}static imageUrlForRestaurant(restaurant){return(`/img/${restaurant.photograph }.jpg`)}imageUrlForRestaurant(restaurant){if(!restaurant.photograph){return(`/img/noimage.png`)}return(`/img/${restaurant.photograph }.jpg`)}static mapMarkerForRestaurant(restaurant,map){const marker=new L.marker([restaurant.latlng.lat,restaurant.latlng.lng],{title:restaurant.name,alt:restaurant.name,url:DBHelper.urlForRestaurant(restaurant)});marker.addTo(newMap);return marker}static addPendingRequestToQueue(url,method,body){const dbPromise=idb.open('restaurant-reviews');dbPromise.then(db=>{const tx=db.transaction('pending','readwrite');tx.objectStore('pending').put({data:{url,method,body}})}).catch(error=>{}).then(DBHelper.nextPending())}static nextPending(){DBHelper.attemptCommitPending(DBHelper.nextPending)}static attemptCommitPending(callback){let url;let method;let body;dbPromise.then(db=>{if(!db.objectStoreNames.length){console.log('Database not available');db.close();return}const tx=db.transaction('pending','readwrite');tx.objectStore('pending').openCursor().then(cursor=>{if(!cursor){return}const value=cursor.value;url=cursor.value.data.url;method=cursor.value.data.method;body=cursor.value.data.body;if((!url||!method)||(method==='POST'&&!body)){cursor.delete().then(callback());return};const properties={body:JSON.stringify(body),method:method};console.log('sending post from queue: ',properties);fetch(url,properties).then(response=>{if(!response.ok&&!response.redirected){return}}).then(()=>{const deltx=db.transaction('pending','readwrite');deltx.objectStore('pending').openCursor().then(cursor=>{cursor.delete().then(()=>{callback()})});console.log('deleted pending item from queue')})}).catch(error=>{console.log('Error reading cursor');return})})}static updateCachedRestaurantData(id,updateObj){const dbPromise=idb.open('restaurant-reviews');dbPromise.then(db=>{console.log('Getting db transaction');const tx=db.transaction('restaurants','readwrite');const value=tx.objectStore('restaurants').get('-1').then(value=>{if(!value){console.log('No cached data found');return}const data=value.data;const restaurantArr=data.filter(r=>r.id===id);const restaurantObj=restaurantArr[0];if(!restaurantObj){return}const keys=Object.keys(updateObj);keys.forEach(k=>{restaurantObj[k]=updateObj[k]});dbPromise.then(db=>{const tx=db.transaction('restaurants','readwrite');tx.objectStore('restaurants').put({id:'-1',data:data});return tx.complete})})});dbPromise.then(db=>{console.log('Getting db transaction');const tx=db.transaction('restaurants','readwrite');const value=tx.objectStore('restaurants').get(id+'').then(value=>{if(!value){console.log('No cached data found');return}const restaurantObj=value.data;console.log('Specific restaurant obj: ',restaurantObj);if(!restaurantObj){return}const keys=Object.keys(updateObj);keys.forEach(k=>{restaurantObj[k]=updateObj[k]});dbPromise.then(db=>{const tx=db.transaction('restaurants','readwrite');tx.objectStore('restaurants').put({id:id+'',data:restaurantObj});return tx.complete})})})}static updateFavorite(id,newState,callback){const url=`${DBHelper.DATABASE_URL }/${ id }/?is_favorite=${ newState }`;const method='PUT';DBHelper.updateCachedRestaurantData(id,{'is_favorite':newState});DBHelper.addPendingRequestToQueue(url,method);callback(null,{id,value:newState})}static updateCachedRestaurantReview(id,bodyObj){console.log('updating cache for new review: ',bodyObj);dbPromise.then(db=>{const tx=db.transaction('reviews','readwrite');const store=tx.objectStore('reviews');console.log('putting cached review into store');store.put({id:Date.now(),'restaurant_id':id,data:bodyObj});console.log('successfully put cached review into store');return tx.complete})}static saveNewReview(id,bodyObj,callback){const url=`${DBHelper.DATABASE_REVIEWS_URL }`;const method='POST';DBHelper.updateCachedRestaurantReview(id,bodyObj);DBHelper.addPendingRequestToQueue(url,method,bodyObj);callback(null,null)}static handleFavoriteClick(id,newState){const fav=document.getElementById('favorite-icon-'+id);fav.onclick=null;DBHelper.updateFavorite(id,newState,(error,resultObj)=>{if(error){console.log('Error updating favorite');return}const favorite=document.getElementById('favorite-icon-'+resultObj.id);favorite.style.background=resultObj.value?`url('/img/icon-fav-1.svg') no-repeat`:`url('/img/icon-fav-2.svg') no-repeat`})}static saveReview(id,name,rating,comment,callback){const btn=document.getElementById('btnSaveReview');btn.onclick=null;const body={restaurant_id:id,name:name,rating:rating,comments:comment,createdAt:Date.now()};DBHelper.saveNewReview(id,body,(error,result)=>{if(error){callback(error,null);return}callback(null,result)})}};