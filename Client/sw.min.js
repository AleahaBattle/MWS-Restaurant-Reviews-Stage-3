if (typeof idb === 'undefined') { self.importScripts('js/idb.js') } if (typeof DBHelper === 'undefined') { self.importScripts('/js/dbhelper.min.js') } let CACHE_VERSION = 1; const CURRENT_CACHES = { prefetch: 'prefetch-cache-v' + CACHE_VERSION }; const getRestaurants = () => { fetch(`${DBHelper.DATABASE_URL}`, { method: 'GET' }).then(response => { if (response.ok) { console.log('Network response returned successfully'); return response.json() } throw new Error('Network response was not returned successfully') }).then(json => { restaurants = json; console.log("restaurants JSON: ", restaurants); return restaurants }).catch(error => { console.log('Fetch in service worker had an error:', error.message) }) }const dbPromise = () => { return idb.open('restaurant-reviews', 1, upgradeDB => { console.log('making a new object store'); switch (upgradeDB.oldVersion) { case 0: case 1: const restaurantsObjectStore = upgradeDB.createObjectStore('restaurants', { keyPath: 'id' }); restaurants.map(restaurant => { restaurantsObjectStore.add(restaurant) }); console.log('Restaurants added successfully') } }) }; self.addEventListener('install', event => { let now = Date.now(); const URLSTOPREFETCH = ['/', '/index.html', '/restaurant.html', '/css/styles.min.css', '/img/', '/js/dbhelper.min.js', '/js/idb.min.js', '/js/main.js', '/js/restaurant_info.js', '/manifest.json', '/sw.min.js']; console.log('Handling install event. Resources to prefetch:', URLSTOPREFETCH); self.skipWaiting(); event.waitUntil(getRestaurants()); event.waitUntil(caches.open(CURRENT_CACHES.prefetch).then(cache => { return cache.addAll(URLSTOPREFETCH).then(() => { console.log('All resources have been fetched and cached.') }); let cachePromises = URLSTOPREFETCH.map(URLSTOPREFETCH => { return fetch(request).then(response => { if (response.status >= 400) { throw new Error('request for ' + URLSTOPREFETCH + ' failed with status ' + response.statusText) } return cache.put(URLSTOPREFETCH, response) }).catch(error => { console.error('Not caching ' + URLSTOPREFETCH + ' due to ' + error) }) }); return Promise.all(cachePromises).then(() => { console.log('Pre-fetching complete.') }) }).catch(error => { console.error('Pre-fetching failed:', error) })) }); self.addEventListener('activate', event => { console.log('Service Worker active'); event.waitUntil(dbPromise()); self.clients.claim(); let expectedCacheNames = Object.keys(CURRENT_CACHES).map(key => { return CURRENT_CACHES[key] }); event.waitUntil(caches.keys().then(cacheNames => { return Promise.all(cacheNames.map(cacheName => { if (expectedCacheNames.indexOf(cacheName) === -1) { console.log('Deleting out of date cache:', cacheName); return caches.delete(cacheName) } })) })) }); self.addEventListener('fetch', event => { console.log('Handling fetch event for', event.request.url); let cacheRequest = event.request; const CacheRequestUrl = new URL(event.request.url); if (event.request.url.indexOf('unpkg.com/leaflet') !== -1 || event.request.url.indexOf('/restaurants/') !== -1) { return } if (event.request.url.indexOf("restaurant.html") > -1) { const cacheURL = "restaurant.html"; cacheRequest = new Request(cacheURL) } if (event.request.url.startsWith('http://localhost:1337/restaurants')) { return } const handleAJAXEvent = (event, id) => { if (CacheRequestUrl.port === '1337') { const parts = CacheRequestUrl.pathname.split('/'); const id = parts[parts.length - 1] === 'restaurants' ? '-1' : parts[parts.length - 1]; handleAJAXEvent(event, id) } else { handleNonAJAXEvent(event, cacheRequest) } let finalJSON; event.respondWith(dbPromise.then(db => { return db.transaction('restaurants').objectStore('restaurants').get(id) }).then(data => { return ((data && data.data) || fetch(event.request).then(fetchResponse => fetchResponse.json()).then(json => { return dbPromise.then(db => { const tx = db.transaction('restaurants', 'readwrite'); const restaurantsObjectStore = tx.objectStore('restaurants').put({ id: id, data: json }); return tx.complete }) })) }).then(finalResponse => { return new Response(JSON.stringify(finalResponse)) }).catch(error => { return new Response('Error fetching data', { status: 500 }) })) }; const handleNonAJAXEvent = (event, cacheRequest) => { event.respondWith(caches.match(cacheRequest).then(response => { return (response || fetch(event.request).then(fetchResponse => { return caches.open(CURRENT_CACHES).then(cache => { if (fetchResponse.url.indexOf('restaurant.html') === -1) { cache.put(event.request, fetchResponse.clone()) } return fetchResponse }) }).catch(error => { if (event.request.url.indexOf('.jpg') > -1) { return caches.match('/img/noimage.png') } return new Response('Application is not connected to the internet', { status: 404, statusText: 'Application is not connected to the internet' }) })) })) }event.respondWith(caches.match(event.request).then(response => { if (response) { console.log('ServiceWorker returning cache response:', response); return response } console.log('No response found in cache. About to fetch from network...'); return fetch(event.request).then(response => { console.log('Response from network is:', response); return response }).catch(error => { console.error('Fetching failed:', error); throw error }); let fetchRequest = event.request.clone(); return fetch(fetchRequest).then(response => { if (!response || response.status !== 200 || response.type !== 'basic') { cache.put(request, response); return response } let responseClone = response.clone(); caches.open(CACHE_VERSION).then(cache => { cache.put(request, responseClone) }); if (response.status < 400) { cache.put(event.request, response.clone()) } else { console.log('  Not caching the response to', event.request.url) } return response }) })) });